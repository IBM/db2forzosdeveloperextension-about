var store = [{
        "title": "Welcome to Jekyll!",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   Jekyll requires blog post files to be named according to the following format:   YEAR-MONTH-DAY-title.MARKUP   Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.  Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.   ","categories": ["jekyll","update"],
        "tags": [],
        "url": "/jekyll/update/2021/02/04/welcome-to-jekyll.html",
        "teaser": null
      },{
        "title": "Deploying, running,and debugging stored procedures",
        "excerpt":"This article shows you how to use Db2 Developer Extension to deploy a native SQL stored procedure (NSP) with various deployment options: enabling debug, altering previous deployments, setting target schema, and others. It also walks you through the process of debugging and running an NSP.   Tip: If you’re new to stored procedures, make sure you’re familiar with the information in Creating stored procedures first.   One big advantage of using Db2 Developer Extension to deploy an NSP, as opposed to manually executing SQL, is that you can save the various deployment options separately from the SQL itself, which means that you can push your code into a source code manager, such as GitHub, without having to remove the deployment debug options first.   Another advantage is that you don’t need to specify --#SET TERMINATOR in the header of .spsql files. Db2 Developer Extension uses the number sign character (#) as the default terminator character, but you can use any terminator character you want by setting a SQL routine option (explained later in this article).   Note: Currently, Db2 Developer Extension deploy, debug, and run options support only one NSP per .spsql file. When NSP options are specified, only the first NSP in the file will be executed; additional NSPs and SQL statements will be ignored.   We’ll use the following example stored procedure throughout this article to demonstrate how to deploy, run, and debug an NSP. This NSP will read the total salary, including bonuses, from the table DSN8B10.EMP from a passed in-parameter DEPTNUMBER. You can paste it into a file so that you try things out for yourself.   RETURNDEPTSALARY.spsql   CREATE PROCEDURE ADMF001.RETURNDEPTSALARY  (IN DEPTNUMBER CHAR(3),   OUT DEPTSALARY DECIMAL(15,2),   OUT DEPTBONUSCNT INT)  LANGUAGE SQL  READS SQL DATA  P1: BEGIN      DECLARE EMPLOYEE_SALARY DECIMAL(9,2);      DECLARE EMPLOYEE_BONUS DECIMAL(9,2);      DECLARE TOTAL_SALARY DECIMAL(15,2) DEFAULT 0;      DECLARE BONUS_CNT INT DEFAULT 0;      DECLARE END_TABLE INT DEFAULT 0;      DECLARE C1 CURSOR FOR       SELECT SALARY, BONUS FROM DSN8B10.EMP        WHERE WORKDEPT = DEPTNUMBER;      DECLARE CONTINUE HANDLER FOR NOT FOUND       SET END_TABLE = 1;      DECLARE EXIT HANDLER FOR SQLEXCEPTION       SET DEPTSALARY = NULL;      OPEN C1;      FETCH C1 INTO EMPLOYEE_SALARY, EMPLOYEE_BONUS;      WHILE END_TABLE = 0 DO       SET TOTAL_SALARY = TOTAL_SALARY + EMPLOYEE_SALARY + EMPLOYEE_BONUS;       IF EMPLOYEE_BONUS &gt; 0 THEN        SET BONUS_CNT = BONUS_CNT + 1;       END IF;       FETCH C1 INTO EMPLOYEE_SALARY, EMPLOYEE_BONUS;      END WHILE;      CLOSE C1;      SET DEPTSALARY = TOTAL_SALARY;      SET DEPTBONUSCNT = BONUS_CNT;  END P1   Here’s how that same stored procedure looks in Db2 Developer Extension:      The file extension of .spsql identifies it as a stored procedure. When you open a .spsql file in Db2 Developer Extension, you get some additional actions in the toolbar in the upper right corner of the view:      From left to right, these actions are Deploy, Debug, and Run. We’ll cover each one in the following sections.   Deploying a stored procedure   Click the Deploy action to open the Deployment view. This is where you can set and customize deployment options and save the options for the .spsql file. These options are used only during deployment and do not impact the DDL source code.   The Deployment view consists of two sections: Deployment options and Routine options.   Deployment options              Use the Database connection option to select a connection from the list of defined connections. See Creating a database connection for more information.            Use the Target schema option for unqualified NSPs. This field is enabled only for unqualified NSPs. If the NSP is qualified (like the one in our example CREATE PROCEDURE statement, which is qualified to ADMF001), the field is disabled. If you leave this field empty, the JDBC property currentSchema will be used. If currentSchema is not set, the JDBC connection username will be used.            Use the Build owner option to specify the owner of the NSP. If this field is left empty, the JDBC property currentSQLID will be used. If currentSQLID is not set, the JDBC connection username will be used.       Use the Default path option for resolving an unqualified data type, function, or procedure referenced by the procedure that’s being deployed. You can specify multiple schemas, each one separated by a comma. For example:       \"ADMF002\",\"ADMF003\",\"ADMF004\"                Use the Duplicate handling option to specify the behavior of the deployment if the procedure already exists:                       Alter duplicates modifies the CREATE PROCEDURE DDL to ALTER PROCEDURE if the procedure already exists.           Exception: If you’re using CREATE OR REPLACE PROCEDURE, which is available in Db2 12 function level 507 or later, this option does not result in any modifications.                        Drop duplicates calls DROP PROCEDURE before running the CREATE PROCEDURE DDL if the procedure already exists.                        Treat duplicate deployments as errors returns an error if the procedure already exists.                   Note: Not all options mentioned above are displayed due to screen size limit.   If you’re new to SQL and want more information about embedding SQL in host languages, there’s a lot of information about this topic in the Db2 for z/OS documentation.   Routine options              Use the Enable debugging option to specify whether this procedure is available to be debugged.            Use the WLM environment option to specify which Workload Manager environment will be used to debug the procedure. If you enable debugging but leave this field empty, the default WLM environment will used.            Use the ASU time limit option to set the ASUTIME, which is the number of CPU seconds permitted for each SQL statement. The default value of 0 means NO LIMIT.            Use the Additional routine options field to specify any additional options that you want to include. Separate each option with a semicolon. For example:       QUALIFIER ADMF002; ISOLATION LEVEL RS          Click Deploy to finish the configuration and begin the deployment process for the procedure.       Debugging a stored procedure   The Debug action allows you to debug your stored procedure by using the native IDE debugger. You can set breakpoints in the editor, and you can watch values change over time in the debug environment (note that conditional breakpoints currently aren’t supported). Setting conditional breakpoints is covered later in this article.   You can also specify additional debugging options by using the Run SQL Options dialog, which is described later in this article. If input variables are specified in the SQL, you’ll be prompted to specify values for them before the SQL goes through debugging.     Click the Debug action to start debugging process. If your NSP contains input variables, you’ll be prompted to specify values for them before the SQL goes through debugging, as shown in the following figure. Note that built-in data types for each input variable are detected automatically and are set to the correct data type.      After you specify input parameter values, click Debug. Set the breakpoints for where you want the debugger to pause execution:      When the debugging process starts, the following toolbar is displayed at the top of the view:      You use this toolbar to step through your code. From left to right, these actions are:           Continue execution of the program until it hits a breakpoint, encounters an error, or completes            Step Over to the next line of the program in the same code level            Step Into the program to enter a deeper code level if the current line is a method            Step Out to the caller if the current code level is inside a method            Restart the debugging program            Stop the debugging program       Click the Run and Debug icon in the Activity Bar () to display the following sections:           The Variables section contains variables declared through program execution and keeps track of the defined value of each variable as the debugger works its way through the code.            Use the Watch section to specify variables or expressions that you want to be evaluated by the debugger.            The Call stack section keeps track of the current code level during debugger execution.            The Breakpoints section keeps track of the breakpoints set throughout the code module.       For more information about debugging your code in Visual Studio Code, see https://code.visualstudio.com/docs/editor/debugging.   Setting conditional hit-count breakpoints   You can specify a hit count when you define a breakpoint, which means that when the breakpoint is reached, instead of pausing, execution continues until the hit count that you specified is reached. This feature is useful when you debug stored procedures that contain loops. You can allow execution to continue for the specified number of loops, and then debug the code when that number is reached.   To set a breakpoint that includes a hit count:      For a stored procedure that has already been deployed, right-click and select Debug Stored Procedure.   Set any input parameters that need to be set.   Click Debug. A .spsql file opens and the debugger starts at the top of this file.   Click the line that you want to set the conditional breakpoint for, then right-click and select Edit Breakpoint &gt; Add Conditional Breakpoint &gt; Hit Count. (Note that in this release, the Expression and Log Message options are not supported.)   Specify the number of times the loop should be run before the debugger pauses.   Click Continue () to proceed with debugging.      The breakpoints that you set persist on the file. You don’t need to reset these breakpoints if you want to debug this file again.   You can clear breakpoints by deselecting them in the BREAKPOINTS view or by clicking on and removing them individually from the file.   Running a stored procedure   Click the Run action to start execution process. If your NSP contains input variables, you’ll be prompted to specify values for them before the NSP executes, as shown in the following figure. Note that built-in data types for each input variable are detected automatically and are set to the correct data type.   If you have an input type that’s an array, you’d specify the values like this:   numeric:   [1; 2; 3] character: [hello; world]      After your NSP is executed, the following output is displayed in these tabs:      The Status tab contains overall execution status. If an error occurred, the status will contain SQL code, SQL state, and Message text.         The Parameters tab contains variable information for passed-in parameters.         The SQL Results view contains data if a result set is expected (in our NSP example, a result set isn’t expected so the Result tab isn’t shown).   Specifying additional options   You can specify and save additional NSP debug and run options by right-clicking inside the editor and selecting Run SQL Options.      …which opens the JDBC runtime options view:      This article covers just the following options that you can set in this view:           Use the Statement terminator character option to set the statement terminator for the file.            Use the Current schema option for resolving regular object types such as tables, views, and indexes.            Use the Current path option for resolving an unqualified data type, function, or procedure referenced by the procedure that is being deployed.  You can specify multiple schemas by separating each one with a comma. For example:        \"ADMF002\",\"ADMF003\",\"ADMF004\"           About commit and rollback options: The commit and rollback options behave a little differently with stored procedures. First, by default, all stored procedures run with COMMIT ON RETURN NO. You can change this behavior by including the COMMIT ON RETURN YES clause in your stored procedure DDL. If you need more control over the SQL statements in a stored procedure at the unit of work level, see COMMIT and ROLLBACK statements in a stored procedure.   Second, Db2 Developer Extension runs only the first stored procedure in a file and ignores any other SQL statements that you might have selected to run. If you select Commit on completion or Rollback changes on completion, processing will end after the first stored procedure is processed, even if you intended to run additional SQL statements in that same file. See Committing and rolling back changes for more information.   ","categories": [],
        "tags": [],
        "url": "/2021/03/12/Deploying-running-and-debugging-stored-procedures-basics.html",
        "teaser": null
      },{
        "title": "Getting started",
        "excerpt":"Db2 for z/OS Developer Extension provides a number of features that make it easy for you to write well-formed SQL, including:      Code snippets   Syntax highlighting   Code completion   Signature help   It also also provides built-in capability for connecting to Db2 for z/OS databases and running your SQL. This article provides an introduction to using these basic features.   Creating a simple SQL statement           Open the Db2 Developer Extension view in Visual Studio Code either by clicking View &gt; Extensions and selecting it from the list of extensions or by clicking the following icon in the Activity Bar:             Now, create a new file by clicking File &gt; New File. Save your file as anyname.sql. The .sql suffix identifies the file to Db2 Developer Extension as an SQL file, so as soon as you save it you can start using Db2 Developer Extension’s editing features.       Note: Although our examples use a .sql file, you can embed SQL in any type of file and run that SQL directly from Db2 Developer Extension. See Running SQL from different types of files for more information.            Type the first letters of the SELECT statement. You’ll only need to type a few letters before SELECT statement shows up in the list of available SQL elements.                    Click SELECT statement to insert a code snippet that provides the basic structure of this statement, including required and commonly used parameters.              Notice a few things about the code that was added:                       The snippet contains just the basic parameters. Many SQL statements have a ton of parameters, too many for even the most experienced developer to remember, so a link to the complete syntax is provided at the top of the snippet.                        The syntax elements are color coded based on element type. For example, keywords are one color and variables are a different color. Syntax highlighting makes it easier to parse your code and to pick out the elements that you’re looking for. Also, if you prefer to use a different color scheme, you can customize the highlighting theme to suit your preferences.                        Hover over one of the elements that’s underlined with a squiggly line, such as search-condition,  and notice that a message is displayed that indicates a syntax error. Whenever possible, these messages include potential fixes for the syntax error. To display all of the syntax errors in a file, you can click View problems in one of these pop-up messages or you can open the PROBLEMS by clicking View &gt; Problems.                         Let’s get back to that SELECT statement. Highlight column-name after the SELECT keyword, type LOC and press Ctrl + Space. The LOCATE_IN_STRING clause shows up in a list of available syntax elements. Select it to insert it, then type an open parenthesis to display a description of the LOCATE_IN_STRING syntax and a link to detailed reference information about it.           These features are useful when you know which syntax element you want to insert, but maybe you don’t know the precise syntax that you need to enter. They also save you time and reduce the chance that you enter something incorrectly.  ","categories": [],
        "tags": [],
        "url": "/2021/03/12/Getting-started.html",
        "teaser": null
      },{
        "title": "Running SQL from different types of files",
        "excerpt":"A unique and extremely useful feature of Db2 Developer Extension is the ability to run your SQL code directly from any type of file without modifying it to accommodate the syntax rules of the language that you’re writing in. Whether you’re writing in a traditional mainframe language such as COBOL, PL/I, JCL or C or in a modern language such as Python, Node.js, or Rust, or even playing around by using a text file, you can embed your SQL in the file, select it, run it, and view the results.   This feature is useful for validating your SQL code from directly within the host language file, without the overhead of copying and pasting it into a .sql or, for stored procedures, into a .spsql file first.   Using this feature is pretty straightforward. The only prerequisite is that you have a database connection.  You can associate a specific connection to the file that you want to run your SQL from, but if you don’t, Db2 Developer Extension will try to establish a connection for you.      Open a file and add a SQL statement.        As an optional step, you can specify JDBC runtime options by right-clicking anywhere in the editor and selecting Run SQL Options from the context menu.       For example, you can specify commit and rollback settings, and you can set the CURRENT SCHEMA and CURRENT PATH special registers. For information about the commit and rollback options, see  Committing and rolling back changes.       Highlight the statement, right-click it, and select Run Selected SQL from the context menu.   That’s it. Results are displayed in the SQL Results page that opens when the statement completes and stored in the Query History view.      One other thing: if you’re coding in a .sql file, you can use Run Selected SQL to run just the specific statements that you’re working on, or you can run the entire file by selecting Run All.    If you’re new to SQL and want more information about embedding SQL in host languages, there’s a lot of information about this topic in the Db2 for z/OS documentation.   Examples   The following examples show this feature in action with several different programming languages.   C example     COBOL example     Java example     JCL example     Node.js example     Python example    ","categories": [],
        "tags": [],
        "url": "/2021/03/12/Running-SQL-from-different-types-of-files.html",
        "teaser": null
      },{
        "title": "Tips and tricks",
        "excerpt":"Visual Studio Code and Db2 Developer Extension provide a modern IDE experience for Db2 for z/OS application developers. With this transition, are you taking full advantage of the editor and extension’s features? Read along to learn how you can work more efficiently in this new development environment.   Visual Studio Code tips   Visual Studio Code has many useful features to increase your productivity. You can apply the following tips to many different extensions, but this article presents them from the perspective of Db2 Developer Extension.   Running commands from the Command Palette   Visual Studio Code’s Command Palette allows you to execute commands quickly without navigating through the user interface. Visual Studio Code provides built-in commands, and Db2 Developer Extension provides its own commands.   To run a Db2 Dev Extension command, open the Command Palette and start typing “Db2 Developer Extension.” You’ll be presented with a list of all the extension-related commands that you can execute.      Creating your own code snippets   Visual Studio Code has built-in snippets and Db2 Dev Extension has its own snippets. If you want to create your own set of code snippets, read Create your own snippets in the Visual Studio Code documentation.   Here’s an example of how to create your own CREATE TABLESPACE snippet for files associated with the SQL language.     Open the Command Palette and select Preferences: Configure User Snippets.   Select sql (SQL) from the list.   In the snippet file, paste the following content and save it.     {   \"CREATE TABLESPACE statement\": {     \"prefix\": \"CREATE TABLESPACE statement\",     \"body\": [       \"CREATE TABLESPACE ${1:tablespace-name}\",       \"\\tIN ${2:database-name}\",       \"\\tUSING STOGROUP ${3:stogroup-name};\",     ],     \"description\": \"Sample CREATE TABLESPACE statement\"   } }           Now start typing CREATE TABLESPACE in any SQL file to use the snippet.      Db2 Developer Extension tips   Db2 Developer Extension provides syntax highlighting, code snippets, SQL execution support, and native stored procedure support. The following tips are useful when you’re working with the extension.   Changing a connection name   When you create a connection, a connection name is automatically generated based on the connection information. You can change this name by editing the connection and changing the Connection name field.   Changing the connection that’s used to run SQL   Before you can run SQL from a file, you need to associate a Db2 connection to the file. To change the connection that’s associated with a file, open the file and click on the connection in the Status Bar. Select a different connection from the list that’s displayed.   Note: The message “No connection” is displayed in the Status Bar if a connection hasn’t been associated with the file.      This method of changing the connection also applies to running and debugging native stored procedures, but it doesn’t apply to deploying native stored procedures. You select the connection that’s used to deploy a native stored procedure in the Deployment options.   Comparing SQL results   When you open SQL results for a completed execution, the results are displayed in the active editor group. To compare two SQL results side-by-side, open each set of SQL results in different editor groups.      Saving SQL results to a file   Any SQL results that generate a result set can be saved to a file. To save the results to a file, open a SQL result, go to the Result tab, and click the Save icon. When prompted, enter the location and name of the file. Press Enter to save the results to the specified file.      Troubleshooting   When the extension is not working as expected, you can check the extension’s logs to see if you can resolve the issue yourself. If you can’t resolve the issue yourself, you can open an issue on the extension’s GitHub Issues and attach the logs. The following sections describe how to enable, view, and find the extension’s logs.   Enabling logging   When logging is enabled, Db2 Developer Extension collects information when you’re using the extension, and it collects JDBC information when you’re interacting with Db2 systems.           To enable the extension’s logging, open the Command Palette and select Preferences: Open Workspace Settings. Search for the db2forzosdeveloperextension.debug.logLevel setting and select a log level.            To enable JDBC logging, edit a connection and enable the driver trace in the Tracing tab.       Viewing the logs   To view the logs collected by Db2 Developer Extension directly in Visual Studio Code, go to View &gt; Output. Select the db2forzosdeveloperextension channel from the dropdown menu. Only the general extension logs are printed here. Instructions for viewing the JDBC logs are provided in the following section.   Locating the log files   To locate the log files that are produced by Db2 Developer Extension, open the Command Palette and select Developer: Open Extension Logs Folder. The logs for Db2 Developer Extension are located in the IBM.db2forzosdeveloperextension folder.   Files that start with client and server are the general Db2 Developer Extension logs.  Files that start with a connection’s name are the JDBC logs for that connection.   ","categories": [],
        "tags": [],
        "url": "/2021/03/13/Tips-and-tricks.html",
        "teaser": null
      },{
        "title": "Committing and rolling back changes",
        "excerpt":"Db2 Developer Extension provides a lot of flexibility with committing and rolling back the results of running SQL statements. This granular level of control is especially useful when you’re prototyping and testing because it allows you to identify which statements run successfully and which cause errors without potentially corrupting your test system.   For example, you can:      Commit the changes for each SQL statement as soon as it completes successfully   Commit the changes for all SQL statements only if all the statements run successfully   Roll back all of the changes even if all of the statements run successfully   Depending on the commit or rollback option you select, you have the following options for what happens when an error occurs while running your SQL:      Continue to process the remaining SQL statements that you selected to run   Stop processing as soon as the first error occurs   Stop processing and immediately roll back all changes   You set these options by right-clicking in your file and selecting Run SQL Options from the context menu to display the JDBC runtime options view. You use the Action when script runs successfully box to set commit and rollback options, and you use the Action when an error occurs box to control how Db2 Developer Extension responds when a SQL statement fails.   Let’s start with this scenario: Our company has just formed a new Client Support department and has staffed it with some existing employees and some new employees. We need to update two tables with information about the new department and its members. We’ll use a couple of Db2-supplied sample tables, DSN8C10.DEPT and DSN8C10.EMP, to demonstrate how the commit, roll back, and error-handling options work.   Here’s the correct SQL for making these changes:  UPDATE DSN8C10.DEPT SET DEPTNAME = 'CLIENT SUPPORT' WHERE DEPTNO = 'E01'; INSERT INTO DSN8C10.DEPT VALUES ('A01', 'AI AD TEAM', '000070', 'D01', 'SVL'); SELECT * FROM DSN8C10.DEPT WHERE DEPTNO = 'A01'; UPDATE DSN8C10.EMP SET SALARY = SALARY * 1.1 WHERE WORKDEPT = 'A00'; SELECT * FROM DSN8C10.EMP WHERE WORKDEPT = 'A00';   To help demonstrate the available actions when an error occurs, we’re going to introduce a few errors into this SQL in the following sections.   Commit after each statement   Select Commit after each statement to commit each individual SQL statement after it runs successfully.        Here’s the SQL to update the DSN8C10.DEPT and DSN8C10.EMP tables. In this example, the INSERT statement and the second UPDATE and SELECT statements contain errors.  UPDATE DSN8C10.DEPT SET DEPTNAME = 'CLIENT SUPPORT' WHERE DEPTNO = 'E01'; INSERT INTO DSN8C10.DEPT VALUES (‘A01’, ‘AI AD TEAM’, ‘M001’, ‘D01’); SELECT * FROM DSN8C10.DEPT WHERE DEPTNO = 'A01'; UPDATE DSN8C10.EMP SET SALARY = SALARY * 1.1 WHERE DEPT = 'A00'; SELECT * FROM DSN8C10.EMP WHERE DEPTNO = 'A00';  And here are the results from running that SQL, which resulted in three errors:      If you select Processing continues, all of the SQL statements will continue to run after the first error (INSERT INTO DSN8C10.DEPT…) occurred, and the successful UPDATE statement will be committed. The results would look like this:         If you select Processing stops, all of the SQL statements after the first error will not be not be run, but the successful UPDATE statement will still be committed. The results would look like this instead:         If you correct the three statements that are causing errors so that all of these statements run error free, each statement will be committed as soon as it ran successfully, regardless of the error action that you selected, and the results would look like this:      Commit on completion   Select Commit on completion to wait until all of the SQL statements that you have selected to run have completed before committing any of them.      Here’s the SQL to update the DSN8C10.DEPT and DSN8C10.EMP tables, which contains one error in the INSERT statement:  UPDATE DSN8C10.DEPT SET DEPTNAME = 'CLIENT SUPPORT' WHERE DEPTNO = 'E01'; INSERT INTO DSN8C10.DEPT VALUES  ('A01', 'AI AD TEAM', 'M001, 'D01'); SELECT * FROM DSN8C10.DEPT WHERE DEPTNO = 'A01'; UPDATE DSN8C10.EMP SET SALARY = SALARY * 1.1 WHERE WORKDEPT = 'A00'; SELECT * FROM DSN8C10.EMP WHERE WORKDEPT = 'A00';  And here are the results from running that SQL, which resulted in a single error:      If you select Processing continues, all the SQL statements that you selected will continue to run after an error occurs, and both UPDATE statements will be committed when processing ends. The results would look like this:         If you select Processing stops, all of the SQL statements after the first error will not be run. Only the first UPDATE statement will be committed when processing ends. The results would look like this:         If you select Processing stops and changes are rolled back, all of the SQL statements after the first error will not be run. Changes from the first UPDATE statement will not be committed. The results would look like this:         If you correct the INSERT statement so all of the SQL statements run error free, each statement would be committed after the last statement ran successfully regardless of the error action that you selected, and the results would look like this:      Roll back changes on completion   Select Roll back changes on completion if you don’t want to commit any changes that result from running your SQL, even if everything runs error free.      Here’s the SQL to update the DSN8C10.DEPT and DSN8C10.EMP tables, which contains one error in the INSERT statement:  UPDATE DSN8C10.DEPT SET DEPTNAME = 'CLIENT SUPPORT' WHERE DEPTNO = 'E01'; INSERT INTO DSN8C10.DEPT VALUES  ('A01', 'AI AD TEAM', 'M001', 'D01'); SELECT * FROM DSN8C10.DEPT WHERE DEPTNO = 'A01'; UPDATE DSN8C10.EMP SET SALARY = SALARY * 1.1 WHERE WORKDEPT = 'A00'; SELECT * FROM DSN8C10.EMP WHERE WORKDEPT = 'A00'  And here are the results from running that SQL, which resulted in a single error:      If you select Processing continues, all the SQL statements that you selected will continue to run after an error occurs. No changes will be committed. The results would look like this:         If you select Processing stops and changes are rolled back, all of the SQL statements after the first error will not be run. Changes from the first UPDATE statement are not committed. The results would look like this:         If you correct the INSERT statement so all of the SQL statements run error free, no changes will be committed regardless of the error action that was selected, and the results would look like this:       ","categories": [],
        "tags": [],
        "url": "/2021/03/16/Committing-and-rolling-back-changes.html",
        "teaser": null
      },{
        "title": "Creating stored procedures",
        "excerpt":"This article covers the basics of using Db2 Developer Extension to create a simple stored procedure and then explains some of the more complex things you might need to do when you create a stored procedure, such as working with DBCS data and user-defined types.    Stored procedures are a powerful tool for increasing the performance and efficiency of distributed applications. Currently, Db2 Developer Extension supports Db2 for z/OS native stored procedures, which are stored procedures that are written entirely in SQL and are created by using the CREATE PROCEDURE or CREATE  OR REPLACE PROCEDURE statement, which is available with Db2 12 function level 507 and later.   Creating a basic stored procedure with code snippets           Open a new .spsql file, and start typing CREATE PROCEDURE. You’ll only need to type a few letters before you see CREATE PROCEDURE in the list of available code snippets.            Select that snippet to populate your file with the basic CREATE PROCEDURE structure (in the following example, the procedure name has already been changed to MYPROCEDURE):          The snippet includes some of the more commonly used parameters and an example SELECT statement. The SELECT statement is the part of the stored procedure that gets executed when the stored procedure is called. To see all of the options that you can define in a stored procedure, open the link that is included at the top of the snippet.    Now this stored procedure is ready to be deployed. To learn how, see Deploying, running, and debugging stored procedures.   Now let’s look at some more complex examples.   Working with double-byte character set (DBCS) data   Languages such as Chinese and Japanese contain double-byte characters, which are characters that are too large to represent with a single byte.  If you write SQL applications that support double-byte character languages, you need to know a bit about how Db2 for z/OS supports DBCS data and how character translation is handled.  This section describes how to code DBCS data in a Db2 for z/OS native stored procedure.    Db2 for z/OS provides DBCS support for the following data types:           GRAPHIC: A fixed-length data type that’s used to store a graphic string.            VARGRAPHIC: A varying-length data type used to store a variable-length graphic string.            CHAR or CLOB defined with “FOR MIXED DATA”: Data types that are used to store character data or mixed data (that is, a combination of single-byte character set (SBCS) characters and multi-byte character set (MBCS) characters).”            DBCLOB: A double-byte character large object.       Tip: Db2 translates all Db2 character data between the internal Db2 table Code Character Set Identifier (CCSID) and the external application CCSID.   The following example shows a user-defined type stored procedure that includes a double-byte DBCLOB variable. When you create a stored procedure that includes DBCLOB parameters, you need to specify PARAMETER CCSID UNICODE, and if the stored procedure includes DBCLOBs in the body, you need to specify APPLICATION ENCODING SCHEMA UNICODE.   CREATE PROCEDURE ADMF001.TEST_DBCLOB (   IN VAR1 DBCLOB,   INOUT VAR2 DBCLOB,   OUT VAR3 DBCLOB   )   APPLICATION ENCODING SCHEME UNICODE   PARAMETER CCSID UNICODE   VERSION V1   ISOLATION LEVEL CS   LANGUAGE SQL   BEGIN     SET VAR2 = '你好';     SET VAR3 = VAR1;   END  Setting this input returns the following output:  VAR1  IN: HELLOWORLD VAR2 OUT: 你好 VAR3 OUT: HELLOWORLD   Working with user-defined types: Distinct   You can create and use a custom data type that’s called a user-defined distinct type in Db2 for z/OS. For example, let’s say that you keep email documents that are sent to your company in a Db2 table. The Db2 data type of an email document is a CLOB, but you define it as a distinct type so that you can control the types of operations that are performed on the email data. The distinct type is defined like this:   CREATE DISTINCT TYPE E_MAIL AS CLOB(5M);   Now you can define and write a native stored procedure or user-defined function to search for and return the following information about an email document:       Subject    Sender    Date sent    Message content    Indicator of whether the document contains a user-specified string.   The following example shows how to create a user-defined distinct type for a currency (US_DOLLAR), how to include it in a stored procedure, and how to do some calculations.    Note that the US_DOLLAR distinct type does not automatically inherit the functions and operators of its source type, DECIMAL. You can use casting functions to assign values other than host variables. Also, the DISTINCT keyword is optional.   CREATE DISTINCT TYPE US_DOLLAR AS DECIMAL(9,2); CREATE TYPE EURO AS DECIMAL(9,2);   CREATE PROCEDURE ADMF001.SALESSUM (    IN DOLLAR_AMOUNT US_DOLLAR,    IN EURO_AMOUNT EURO,    OUT TOTAL_DOLLAR US_DOLLAR,    OUT TOTAL_EURO EURO   )   LANGUAGE SQL   VERSION V1   ISOLATION LEVEL CS    BEGIN     SET TOTAL_DOLLAR = DECIMAL(DOLLAR_AMOUNT)*200;     SET TOTAL_EURO = DECIMAL(EURO_AMOUNT)+300.07;   END  Setting this input returns the following output:  DOLLAR_AMOUNT  IN: 34.50 EURO_AMOUNT    IN: 500 TOTAL_DOLLAR  OUT: 6900.00 TOTAL_DOLLAR  OUT: 30507.00   Working with user-defined types: Arrays   An array value is a structure that contains an ordered collection of elements. Arrays make it easier to exchange long lists of values with the Db2 server. You can create a user-defined data type for an array in Db2 for z/OS.   The following example shows how to create an ordinary array user-defined type (PHONENUMBERS) that can contain a maximum of 50 elements. The elements are of the DECIMAL(10,0) data type. The array index starts with 1.    CREATE TYPE PHONENUMBERS AS DECIMAL(10,0) ARRAY[50];  CREATE PROCEDURE ADMF001.TESTPROC(    IN PHONENUMBER PHONENUMBERS,    OUT outPHONENUMBER PHONENUMBERS   )   LANGUAGE SQL   VERSION V1   ISOLATION LEVEL CS   BEGIN     SET outPHONENUMBER[1]= PHONENUMBER[1];   END  Setting this input returns the following output:   PHONENUMBER      IN: [6262158888;4056789999] outPHONENUMBER  OUT: [6262158888]  The following example shows how to create an ordinary arrays user-defined type for time and timestamp with time zone. The default TIMESTAMP WITH TIME ZONE length is 6.   CREATE TYPE TIMEARRAY AS TIME ARRAY[]; CREATE TYPE TIMESTAMPARRAY AS TIMESTAMP WITH TIME ZONE ARRAY[];  CREATE PROCEDURE ADMF001.TESTPROC (   IN inTIME TIMEARRAY,   IN inTIMESTAMPWITHZONE TIMESTAMPARRAY   OUT outTIME TIME   OUT outTIMESTAPWITHZONE TIMESTAMPARRAY     )   LANGUAGE SQL   VERSION V1   ISOLATION LEVEL CS   BEGIN     SET outTIME = INTIME[1];     SET outTIMESTAMPWITHZONE[1] = inTIMESTAMPWITHZONE[1];   END  Setting this input returns the following output:  inTIME               IN: [08:09:01;10:15:00;11:08:30] inTIMESTAMPWITHZONE  IN: [2020-10-15 15:01:01.111213141516+4:00] outTIME             OUT: 08:09:01 outTIMESTAPWITHZONE OUT: [2020-10-15 15:01:01.111213]  ","categories": [],
        "tags": [],
        "url": "/2021/03/16/Creating-stored-procedures.html",
        "teaser": null
      },{
        "title": "Running SQL",
        "excerpt":"Db2 for z/OS Developer Extension provides a lot of flexibility for running SQL and working with the results.   Preparing to run an SQL statement   When you have some valid SQL and you have a valid database connection, you’re just about ready to run it. There’s a little bit of optional set up you might want to do first.      Create and save a simple SQL statement. For example, the following statement selects the entire contents (a single row) of the Db2 sample table SYSIBM.SYSDUMMY1:     SELECT * FROM SYSIBM.SYSDUMMY1                Right-click anywhere in your .sql file and select Run SQL Options from the context menu to open the following view:              Use this view to set the following options for running your SQL:              Whether to always use an existing database connection to run this script or open a new database connection every time you run this script.       The circumstances under which changes are committed or rolled back.       The statement termination character to use if you don’t want to use the default semicolon (;) character.       Values for the CURRENT SCHEMA and CURRENT PATH special registers and whether these values are always converted to uppercase letters.                Now, you can run your SQL by using any of the following methods:                       Right-click anywhere in your SQL file and click Run All.                        Highlight your SELECT statement, right-click anywhere in your SQL file and click Run Selected SQL. This option is useful for testing and debugging individual SQL statements.                        Use the Visual Studio Code Command Palette.                   The results are displayed in the SQL Results page that opens when the statement completes and stored in the QUERY HISTORY menu in ther right sidebar. You can also save the results in a .csv file or in a spreadsheet.         Running multiple SQL statements   When you run multiple SQL statements simultaneously by using the Run Selected SQL option or all of the SQL statements in a file by using the Run All option, when the statements finish executing, the results are displayed in the Execution Summary page:   INSERT SCREEN SHOT OF EXECUTION SUMMARY PAGE HERE   The Execution Summary page indicates the total number of statements that ran, the execution status of each statement (success, failure, warning), and the total amount of time that it took to run the statements.   Db2 Developer Extension maintains the execution history so that you can compare SQL execution results over time. Statements are grouped together in an expandable section in the Query History view. Click an individual statement to display details about just that statement.   The query history is sorted in descending order by default. To sort the query history in ascending order, hover on the Query History view and click the Sort Query History icon.      Warning and failure icons indicate which statements might need some debugging.  To cycle through all of the statements that failed, click the ??? icon and the next failing SQL statement is displayed.   Running SQL within a stored procedure   You can run SQL within a native stored procedure (NSP) body that contains SQL parameters and SQL variables. You’ll be prompted to specify values for them before the SQL executes. Note that built-in data types for each input variable are detected automatically and are set to the correct data type.     ","categories": [],
        "tags": [],
        "url": "/2021/06/14/Running-SQL.html",
        "teaser": null
      },{
        "title": "Comparing SQL results",
        "excerpt":"When you open SQL results for a completed execution, the results are displayed in the active editor group. To compare two SQL results side-by-side, open each set of SQL results in different editor groups.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Comparing-SQL-results.html",
        "teaser": null
      },{
        "title": "Creating a database connection",
        "excerpt":"Before you can run your SQL, you need to connect to the Db2 for z/OS subsystem that contains the database that you want to work with. You can use Db2 Developer Extension’s integrated database connection capability to add a connection.   From the CONNECTIONS view, click the plus sign (+) to open the Add Connection dialog.              Use the General tab to specify basic connection information about the Db2 subsystem and valid user credentials for connecting to that Db2 subsystem.            If you run into problems when you define a new connection or when you run your SQL against an existing connection, and those problems are related to the data server driver, open the Tracing tab and turn Enable driver trace to On. See Opening an issue and providing logs for more information about the logs that are produced when you enable tracing.            If you want to include additional properties in your database connection, open the Optional tab and enter the property name and assign it a value. Select the checkbox to the left of a property to include it in a database connection. Click the blue plus sign (+) to add a new line.       When you’re done, click Finish. If your database connection was created successfully, it’ll be added to the CONNECTIONS menu in the right side bar. If not, open the Tracing tab, enable tracing, and try again. Then, check the logs for more information about why the connection isn’t being added.   Changing a connection name   When you create a connection, a connection name is automatically generated based on the connection information. You can change this name by editing the connection and changing the Connection name field.   Changing the connection that’s used to run SQL   Before you can run SQL from a file, you need to associate a Db2 connection to the file. To change the connection that’s associated with a file, open the file and click on the connection in the Status Bar. Select a different connection from the list that’s displayed.   Note: The message “No connection” is displayed in the Status Bar if a connection hasn’t been associated with the file.      This method of changing the connection also applies to running and debugging native stored procedures, but it doesn’t apply to deploying native stored procedures. You select the connection that’s used to deploy a native stored procedure in the Deployment options.  ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Creating-a-database-connection.html",
        "teaser": null
      },{
        "title": "Creating your own code snippets",
        "excerpt":"Visual Studio Code has built-in snippets and Db2 Dev Extension has its own snippets. If you want to create your own set of code snippets, read Create your own snippets in the Visual Studio Code documentation.   Here’s an example of how to create your own CREATE TABLESPACE snippet for files associated with the SQL language.     Open the Command Palette and select Preferences: Configure User Snippets.   Select sql (SQL) from the list.   In the snippet file, paste the following content and save it.     {   \"CREATE TABLESPACE statement\": {     \"prefix\": \"CREATE TABLESPACE statement\",     \"body\": [       \"CREATE TABLESPACE ${1:tablespace-name}\",       \"\\tIN ${2:database-name}\",       \"\\tUSING STOGROUP ${3:stogroup-name};\",     ],     \"description\": \"Sample CREATE TABLESPACE statement\"   } }           Now start typing CREATE TABLESPACE in any SQL file to use the snippet.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Creating-your-own-code-snippets.html",
        "teaser": null
      },{
        "title": "Opening an issue and providing logs",
        "excerpt":"When the extension is not working as expected, you can check the extension’s logs to see if you can resolve the issue yourself. If you can’t resolve the issue yourself, you can open an issue on the extension’s GitHub Issues and attach the logs. The following sections describe how to enable, view, and find the extension’s logs.   Enabling logging   When logging is enabled, Db2 Developer Extension collects information when you’re using the extension, and it collects JDBC information when you’re interacting with Db2 systems.           To enable the extension’s logging, open the Command Palette and select Preferences: Open Workspace Settings. Search for the db2forzosdeveloperextension.debug.logLevel setting and select a log level.            To enable JDBC logging, edit a connection and enable the driver trace in the Tracing tab.       Viewing the logs   To view the logs collected by Db2 Developer Extension directly in Visual Studio Code, go to View &gt; Output. Select the db2forzosdeveloperextension channel from the dropdown menu. Only the general extension logs are printed here. Instructions for viewing the JDBC logs are provided in the following section.   Locating the log files   To locate the log files that are produced by Db2 Developer Extension, open the Command Palette and select Developer: Open Extension Logs Folder. The logs for Db2 Developer Extension are located in the IBM.db2forzosdeveloperextension folder.   Files that start with client and server are the general Db2 Developer Extension logs.  Files that start with a connection’s name are the JDBC logs for that connection.   ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Enabling-logging.html",
        "teaser": null
      },{
        "title": "Opening an issue and providing logs",
        "excerpt":"When the extension is not working as expected, you can check the extension’s logs to see if you can resolve the issue yourself. If you can’t resolve the issue yourself, you can open an issue on the extension’s GitHub Issues and attach the logs. The following sections describe how to enable, view, and find the extension’s logs.   Enabling logging   When logging is enabled, Db2 Developer Extension collects information when you’re using the extension, and it collects JDBC information when you’re interacting with Db2 systems.           To enable the extension’s logging, open the Command Palette and select Preferences: Open Workspace Settings. Search for the db2forzosdeveloperextension.debug.logLevel setting and select a log level.            To enable JDBC logging, edit a connection and enable the driver trace in the Tracing tab.       Viewing the logs   To view the logs collected by Db2 Developer Extension directly in Visual Studio Code, go to View &gt; Output. Select the db2forzosdeveloperextension channel from the dropdown menu. Only the general extension logs are printed here. Instructions for viewing the JDBC logs are provided in the following section.   Locating the log files   To locate the log files that are produced by Db2 Developer Extension, open the Command Palette and select Developer: Open Extension Logs Folder. The logs for Db2 Developer Extension are located in the IBM.db2forzosdeveloperextension folder.   Files that start with client and server are the general Db2 Developer Extension logs.  Files that start with a connection’s name are the JDBC logs for that connection.   ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Opening-an-issue-and-providing-logs.html",
        "teaser": null
      },{
        "title": "Preparing to run an SQL statement",
        "excerpt":"When you have some valid SQL and you have a valid database connection, you’re just about ready to run it. There’s a little bit of optional set up you might want to do first.      Create and save a simple SQL statement. For example, the following statement selects the entire contents (a single row) of the Db2 sample table SYSIBM.SYSDUMMY1:     SELECT * FROM SYSIBM.SYSDUMMY1                Right-click anywhere in your .sql file and select Run SQL Options from the context menu to open the following view:              Use this view to set the following options for running your SQL:              Whether to always use an existing database connection to run this script or open a new database connection every time you run this script.       The circumstances under which changes are committed or rolled back.       The statement termination character to use if you don’t want to use the default semicolon (;) character.       Values for the CURRENT SCHEMA and CURRENT PATH special registers and whether these values are always converted to uppercase letters.                Now, you can run your SQL by using any of the following methods:                       Right-click anywhere in your SQL file and click Run All.                        Highlight your SELECT statement, right-click anywhere in your SQL file and click Run Selected SQL. This option is useful for testing and debugging individual SQL statements.                        Use the Visual Studio Code Command Palette.                   The results are displayed in the SQL Results page that opens when the statement completes and stored in the QUERY HISTORY menu in ther right sidebar. You can also save the results in a .csv file or in a spreadsheet.       ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Preparing-to-run-an-SQL-statement.html",
        "teaser": null
      },{
        "title": "Restricting the number of rows returned",
        "excerpt":"TBD  ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Restricting-the-number-of-rows-returned.html",
        "teaser": null
      },{
        "title": "Running SQL from within a stored procedure",
        "excerpt":"You can run SQL within a native stored procedure (NSP) body that contains SQL parameters and SQL variables. You’ll be prompted to specify values for them before the SQL executes. Note that built-in data types for each input variable are detected automatically and are set to the correct data type.   Note that this feature applies to .spsql files only.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Running-SQL-from-within-a-stored-procedure.html",
        "teaser": null
      },{
        "title": "Running SQL with multiple selection scopes",
        "excerpt":"When you’re working in a file that contains a lot of SQL elements, especially in a non-SQL file (for example, Python, Java, etc.), you might want to select and run multiple individual SQL elements instead of having to run the entire statement.  Those elements might be on consecutive lines or they might be scattered throughout the file on different lines.   You can select and run individual elements by holding the Alt key and selecting the elements that you want to run. Then, right-click and select Run Selected SQL.      You can also use column selection mode to select and run individual elements.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Running-SQL-with-multiple-selection-scopes.html",
        "teaser": null
      },{
        "title": "Running commands from the Command Palette",
        "excerpt":"Visual Studio Code’s Command Palette allows you to execute commands quickly without navigating through the user interface. Visual Studio Code provides built-in commands, and Db2 Developer Extension provides its own commands.   To run a Db2 Dev Extension command, open the Command Palette and start typing “Db2 Developer Extension.” You’ll be presented with a list of all the extension-related commands that you can execute.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Running-commands-from-the-command-palette.html",
        "teaser": null
      },{
        "title": "Running multiple SQL statements",
        "excerpt":"When you run multiple SQL statements simultaneously by using the Run Selected SQL option or all of the SQL statements in a file by using the Run All option, when the statements finish executing, the results are displayed in the Execution summary page:      The Execution summary page indicates the total number of statements that ran, the execution status of each statement (success, failure, warning), and the total amount of time that it took to run the statements.   Note: A value of N/A in the Total elapsed time field indicates that the execution results were generated prior to upgrading to Db2 Developer Extension 1.2.   Db2 Developer Extension maintains the execution history so that you can compare SQL execution results over time. Statements are grouped together in an expandable section in the QUERY HISTORY view. Click an individual statement to display details about just that statement.   The query history is sorted in descending order by default. To sort the query history in ascending order, hover on the QUERY HISTORY view and click the Sort Query History icon ().      Warning and failure icons indicate which statements might need some debugging.  To cycle through all of the statements that failed, click the Next Failure icon  () and the next failing SQL statement is displayed.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Running-multiple-SQL-statements.html",
        "teaser": null
      },{
        "title": "Saving SQL results to a file",
        "excerpt":"Any SQL results that generate a result set can be saved to a file. To save the results to a file, open a SQL result, go to the Result tab, and click the Save icon. When prompted, enter the location and name of the file. Press Enter to save the results to the specified file.     ","categories": [],
        "tags": [],
        "url": "/2021/06/15/Saving-SQL-results-to-a-file.html",
        "teaser": null
      },{
        "title": "Formatting SQL",
        "excerpt":"Db2 Developer Extension takes advantage of VSCode’s Format Document and Format Selection capabilities by allowing you to format SQL within all SQL file types, including .ddl, .spsql, .sql, .javaspsql, and .udfsql files.   The ability to format your SQL makes it much easier to parse large blocks of code and to understand the relationship between different blocks of SQL elements and clauses.   The formatting actions are available from the editor context menu, as keyboard shortcuts, and from the Command Palette.     ","categories": [],
        "tags": [],
        "url": "/2021/06/16/Formatting-SQL.html",
        "teaser": null
      },{
        "title": "Limiting the number of rows returned",
        "excerpt":"For statements that return a huge number of rows in a result set, you can limit the number of rows that are returned by using the Max Number of Rows Returned extension setting. The value you specify in this field takes precedence over any FETCH clauses that you might have defined in your SQL.   To  limit the number of rows that get returned when you run SQL statements:           Open Db2 Developer Extension and click the Manage icon at the lower left corner of VS Code window:                   Click Settings &gt; Extensions &gt; IBM Db2 for z/OS Developer Extension.            Specify the maximum number of rows that will be returned in a result set in the Max Number of Rows Returned field:          For example, without setting the Max Number of Rows Returned field, the following SELECT statement will return 50 rows at most, and the following CALL statement will return all available rows:  SELECT NAME, CREATOR, CARDF FROM SYSIBM.SYSTABLES  WHERE CREATOR = 'SYSIBM' FETCH FIRST 50 ROWS ONLY;  CALL SYSIBM.SQLTABLES(?, ?, ?, ?, ?);  If you set the Max Number of Rows Returned field to a positive integer value, let’s say 10, running that SELECT statement will return only 10 rows. The same behavior applies to CALL statements that return a result set or multiple results.     ","categories": [],
        "tags": [],
        "url": "/2021/06/16/Limiting-the-number-of-rows-returned.html",
        "teaser": null
      },{
        "title": "Setting multiple port numbers",
        "excerpt":"To make it easier to open and work in multiple VS Code instances without having to manually change the port settings for each instance, you can specify multiple individual port numbers by separating them with commas, and you can specify a range of port numbers by separating them with a hyphen. For example:   4555, 4556, 4559-4985   To set the port numbers:           Open Db2 Developer Extension and click the Manage icon at the lower left corner of VS Code window:                   Click Settings &gt; Extensions &gt; IBM Db2 for z/OS Developer Extension.            Update the Session Manager Port and Port settings fields with port numbers that are available for you to use:         ","categories": [],
        "tags": [],
        "url": "/2021/06/16/Setting-multiple-port-numbers.html",
        "teaser": null
      }]
